Memoria Ejercicio 1c:

Â¿Por quÃ© es asi?

Podemos ver que el tiempo de ejecucion del programa difiere bastante entre el modo normal y el sorted. Este efecto se ve sobretodo en el tiempo
de construicciÃ³n del Ã¡rbol, pues este proceso requiere mas iteraciones y el alargamiento del tiempo se acumula.
Cuando se ejecuta el modo normal, los nodos se insertan en el arbol en el orden en el que han sido leÃ­dos, cuando se ejecuta el modo sorted, primero se ordena
el array de elementos leÃ­dos del fichero, y despuÃ©s se insertan en el arbol de manera Ã³ptima, es decir, se va insertando la mediana de cada "segmento" del array,
partiÃ©ndolo en dos nuevos fragmentos y llamando de manera recursiva a insertar de nuevo las medianas, hasta que el fragmento se quede sin elementos.
Al hacer esto con el array ordenado, se forma un arbol de bÃºsqueda Ã³ptimo, en el que la busqueda e inserciÃ³n de un elemento tiene una complejidad temporal de nlog2n.
Este resultado se ve en la eficiencia de ejecucion del programa, construyendo un Ã¡rbol menos profundo.

Â¿Hay alguna propiedad del Ã¡rbol que permita explicar este comportamiento?

Al insertar elementos en el Ã¡rbol de manera Ã³ptima, logramos terminar con un arbol de profundidad menor a la que conseguirÃ­amos con el unsorted, lo que implica que 
para cada iteracion con el Ã¡rbol requiere menos pasos y por ende, menos tiempo.





Memoria Ejercicio 2:

Â¿QuÃ© diferencias y similitudes hay entre el TAD SQ y el TAD Cola de la prÃ¡ctica
anterior?

Ambas estructuras de datos operan y se construyen mediante las funciones pop y push, sin embargo, la Cola de la anterior prÃ¡ctica 
seguÃ­a la regla "First in, First out", mientras que la SQ 

Â¿QuÃ© coste (aproximado) tiene la operaciÃ³n de extraer un elemento en el TAD SQ?
Â¿SerÃ­a posible hacer que esta operaciÃ³n fuera ğ’ª(1)? 

